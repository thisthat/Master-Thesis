{
  "name": "mongo-fast-join",
  "version": "0.0.11",
  "description": "Join subdocuments into other mongo documents from other collections",
  "main": "Join.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/Bill4Time/mongo-fast-join.git"
  },
  "keywords": [
    "mongodb",
    "mongo",
    "nodejs",
    "node",
    "javascript",
    "join",
    "mongo-join"
  ],
  "author": {
    "name": "Bill4Time"
  },
  "contributors": [
    {
      "name": "Kyle Housley",
      "email": "khousley@bill4time.com"
    },
    {
      "name": "Jeremy Diviney",
      "email": "jeremy@bill4time.com"
    }
  ],
  "license": "The MIT License (MIT)",
  "bugs": {
    "url": "https://github.com/Bill4Time/mongo-fast-join/issues"
  },
  "readme": "##mongo-fast-join\r\n\r\n\r\nJoin sub documents from other collections into the original query documents and do it as fast as mongo can.\r\n\r\n###Intro\r\n\r\nThis is our stab at the mongo join problem. As you know, joins are not supported by MongoDB natively, and this can be a pain.\r\nWe sought to create a project which performs a join query on mongodb and does it quickly. After a few attempts with less \r\nthan stellar results, we arrived at the current implementation.\r\n\r\n####How did we do it?\r\n\r\nmongo-fast-join is fast because we paginate our join queries. Each document that is going to be joined to another document \r\nrepresents a unique query. This is accomplished with an $or clause. When dealing with only 10,000 original documents, this \r\nwas miserably slow, taking up to a minute to return results on the local network. What a useless tool this would be if it \r\ntook that long to join a measly 10,000 records. Turns out that splitting query into small queries with only 5 conditions \r\nin each $or clause sped the performance up by many orders of magnitude, joining 10,000 documents in less than 200ms.\r\n\r\nWe think that the reason the single query performed so poorly is because the $or clause was not intended to handle 10,000\r\nconditions. It also seems that the query is executed in a single thread (just a guess). \r\n\r\n\r\n####Shut up and take my query!\r\n\r\nThis is the syntax we arrived at:\r\n\r\n```\r\n\r\nvar MJ = require(\"mongo-fast-join\"),\r\n    mongoJoin = new MJ();\r\n\r\n/*\r\n    Say we have a collection of sales where each document holds a manual reference to the product sold. We can join the\r\n    full product document into each sale document. Lets also assume that each product has a reference to some\r\n    manufacturer info.\r\n*/\r\n        \r\nmongoJoin\r\n    .query(\r\n      //say we have sales records and we store all the products for sale in a different collection\r\n      db.collection(\"sales\"),\r\n        {}, //query statement\r\n        {}, //fields\r\n        {\r\n            limit: 10000//options\r\n        }\r\n    )\r\n    .join({\r\n        joinCollection: db.collection(\"products\"),\r\n        //respects the dot notation, multiple keys can be specified in this array\r\n        leftKeys: [\"product_id\"],\r\n        //This is the key of the document in the right hand document\r\n        rightKeys: [\"_id\"],\r\n        //This is the new subdocument that will be added to the result document\r\n        newKey: \"product\"\r\n    })\r\n    .join({\r\n        //say that we want to get the users that commented too\r\n        joinCollection: db.collection(\"manufacturers\"),\r\n        //This is cool, you can join on the new documents you add to the source document\r\n        leftKeys: [\"product.manufacturer_id\"],//This field accepts many keys, which amounts to a composite key\r\n        rightKeys: [\"_id\"],\r\n        //unfortunately, as of now, you can only add subdocuments at the root level, not to arrays of subdocuments\r\n        newKey: \"manufacturer\"//The upside is that this serve the majority of cases\r\n    })\r\n    //Call exec to run the compiled query and catch any errors and results, in the callback\r\n    .exec(function (err, items) {\r\n        console.log(items);\r\n    });\r\n\r\n```\r\n\r\nThe resulting document should have 10000 sales records with the product sold and manufaturer info attached to each sale\r\nin a structure like this:\r\n\r\n```\r\n\r\n{\r\n    _id: 1,\r\n    product_id: 2,\r\n    product: {\r\n        _id: 2,\r\n        manufacturer_id: 3\r\n        name: \"Wooden Spoon\"\r\n    },\r\n    manufacturer: {\r\n        _id: 3,\r\n        name: \"Betty Crocker\"\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/Bill4Time/mongo-fast-join",
  "_id": "mongo-fast-join@0.0.11",
  "dist": {
    "shasum": "c04f62c834fdc0e32ea36bc303b7974fce8026ef",
    "tarball": "http://registry.npmjs.org/mongo-fast-join/-/mongo-fast-join-0.0.11.tgz"
  },
  "_from": "mongo-fast-join@*",
  "_npmVersion": "1.3.14",
  "_npmUser": {
    "name": "kylehousley",
    "email": "khousley@bill4time.com"
  },
  "maintainers": [
    {
      "name": "kylehousley",
      "email": "khousley@bill4time.com"
    }
  ],
  "directories": {},
  "_shasum": "c04f62c834fdc0e32ea36bc303b7974fce8026ef",
  "_resolved": "https://registry.npmjs.org/mongo-fast-join/-/mongo-fast-join-0.0.11.tgz"
}
